#!/usr/bin/env groovy

// ============================================================================
// CONFIGURABLE VARIABLES - Easy to change target Artifactory
// ============================================================================

// PIPELINE PARAMETERS (can be overridden when running)
properties([
    parameters([
        booleanParam(
            name: 'LOCAL_TESTING',
            defaultValue: true,
            description: 'Force local testing mode (set to false for production)'
        ),
        string(
            name: 'ARTIFACTORY_URL_OVERRIDE',
            defaultValue: '',
            description: 'Override Artifactory URL (e.g., http://my-artifactory:8082/artifactory)'
        ),
        string(
            name: 'BINARIES_REPO_OVERRIDE',
            defaultValue: '',
            description: 'Override binaries repository name (e.g., my-jfcm-binaries)'
        ),
        booleanParam(
            name: 'SKIP_PACKAGING',
            defaultValue: false,
            description: 'Skip package creation (NPM, Chocolatey, etc.)'
        ),
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Skip cross-platform testing'
        )
    ])
])

// Environment detection for local vs production testing
// Check multiple indicators for local environment
def jenkinsUrl = env.JENKINS_URL ?: env.BUILD_URL ?: ''
def isLocalTesting = params.LOCAL_TESTING == true ||
                     jenkinsUrl.contains('localhost') || 
                     jenkinsUrl.contains('127.0.0.1') ||
                     jenkinsUrl.contains('host.docker.internal') ||
                     env.NODE_NAME == 'master' ||
                     env.NODE_NAME == 'built-in'

// Artifactory Configuration (easily configurable with parameter overrides)
def artifactoryConfig = [
    local: [
        url: params.ARTIFACTORY_URL_OVERRIDE ?: "http://host.docker.internal:8082/artifactory",
        credentials: "local-artifactory-creds",
        binariesRepo: params.BINARIES_REPO_OVERRIDE ?: "jfcm",
        npmRepo: "jfcm-npm", 
        debsRepo: "jfcm-debs",
        rpmsRepo: "jfcm-rpms",
        dockerRepo: "jfcm-docker"
    ],
    production: [
        url: params.ARTIFACTORY_URL_OVERRIDE ?: "https://releases.jfrog.io/artifactory",
        credentials: "repo21",
        binariesRepo: params.BINARIES_REPO_OVERRIDE ?: "jfcm",
        npmRepo: "jfcm-npm",
        debsRepo: "jfcm-debs", 
        rpmsRepo: "jfcm-rpms",
        dockerRepo: "jfcm-docker"
    ]
]

// Select configuration based on environment
def currentConfig = isLocalTesting ? artifactoryConfig.local : artifactoryConfig.production

echo "🎯 Environment: ${isLocalTesting ? 'LOCAL TESTING' : 'PRODUCTION'}"
echo "Artifactory URL: ${currentConfig.url}"
echo "Binaries repo: ${currentConfig.binariesRepo}"

// For local testing, use node{} which is equivalent to "agent any"
// For production, use specific label
if (isLocalTesting) {
    node {
        executePipeline()
    }
} else {
    node('docker-ubuntu20-xlarge') {
        executePipeline()
    }
}

def executePipeline() {
    cleanWs()
    
    // Global variables
    def architectures = [
        [pkg: 'jfcm-windows-amd64', goos: 'windows', goarch: 'amd64', fileExtension: '.exe', chocoImage: 'jfrog-docker/linuturk/mono-choco'],
        [pkg: 'jfcm-linux-386', goos: 'linux', goarch: '386', fileExtension: '', debianImage: 'jfrog-docker/i386/ubuntu:20.04', debianArch: 'i386'],
        [pkg: 'jfcm-linux-amd64', goos: 'linux', goarch: 'amd64', fileExtension: '', debianImage: 'jfrog-docker/ubuntu:20.04', debianArch: 'x86_64', rpmImage: 'almalinux:8.10'],
        [pkg: 'jfcm-linux-arm64', goos: 'linux', goarch: 'arm64', fileExtension: ''],
        [pkg: 'jfcm-linux-arm', goos: 'linux', goarch: 'arm', fileExtension: ''],
        [pkg: 'jfcm-mac-amd64', goos: 'darwin', goarch: 'amd64', fileExtension: ''],
        [pkg: 'jfcm-mac-arm64', goos: 'darwin', goarch: 'arm64', fileExtension: ''],
        [pkg: 'jfcm-linux-s390x', goos: 'linux', goarch: 's390x', fileExtension: ''],
        [pkg: 'jfcm-linux-ppc64', goos: 'linux', goarch: 'ppc64', fileExtension: ''],
        [pkg: 'jfcm-linux-ppc64le', goos: 'linux', goarch: 'ppc64le', fileExtension: '']
    ]
    
    def jfcmExecutableName = 'jfcm'
    def identifier = 'v1'
    def jfcmRepoDir = pwd() + "/jfcm/"
    def buildName = 'jfcm-multi-platform'
    def buildNumber = env.BUILD_NUMBER
    def jfcmVersion
    def publishToProd = false
    
    // Determine if this is a production release
    if (env.BRANCH_NAME?.startsWith('v') || env.TAG_NAME?.startsWith('v')) {
        publishToProd = true
        jfcmVersion = env.TAG_NAME ?: env.BRANCH_NAME
    } else {
        jfcmVersion = "dev-${buildNumber}"
    }
    
    timestamps {
        try {
            stage('Checkout') {
                echo "Checking out JFCM repository..."
                checkout scm
                dir(jfcmRepoDir) {
                    // Get the actual version from git or go.mod if available
                    script {
                        try {
                            jfcmVersion = sh(
                                script: 'git describe --tags --exact-match HEAD 2>/dev/null || echo "dev-' + buildNumber + '"',
                                returnStdout: true
                            ).trim()
                        } catch (Exception e) {
                            echo "Could not determine version from git tags, using: ${jfcmVersion}"
                        }
                    }
                    echo "Building JFCM version: ${jfcmVersion}"
                }
            }
            
            stage('Setup') {
                echo "Setting up build environment..."
                setupBuildEnvironment(jfcmRepoDir)
            }
            
            stage('Build JFCM Binaries') {
                echo "Building JFCM binaries for all platforms..."
                buildJfcmBinaries(architectures, jfcmExecutableName, jfcmRepoDir, jfcmVersion)
            }
            
            stage('Sign Binaries') {
                echo "Signing binaries..."
                signBinaries(architectures, jfcmExecutableName, jfcmRepoDir)
            }
            
            stage('Create Packages') {
                echo "Creating distribution packages..."
                createPackages(architectures, jfcmExecutableName, jfcmRepoDir, jfcmVersion, identifier)
            }
            
            stage('Test Packages') {
                echo "Testing created packages..."
                testPackages(architectures, jfcmExecutableName, jfcmRepoDir)
            }
            
            stage('Upload to Artifactory') {
                echo "Uploading artifacts to Artifactory..."
                uploadToArtifactory(architectures, jfcmExecutableName, jfcmRepoDir, jfcmVersion, identifier, buildName, buildNumber)
            }
            
            if (publishToProd) {
                stage('Publish Packages') {
                    echo "Publishing packages to production repositories..."
                    publishPackages(architectures, jfcmExecutableName, jfcmRepoDir, jfcmVersion, identifier)
                }
                
                stage('Update Documentation') {
                    echo "Updating installation documentation..."
                    updateInstallationDocs(jfcmVersion)
                }
            }
            
            stage('Cleanup') {
                echo "Cleaning up build artifacts..."
                cleanupBuildArtifacts(jfcmRepoDir)
            }
            
        } catch (Exception e) {
            currentBuild.result = 'FAILURE'
            echo "Build failed with error: ${e.getMessage()}"
            throw e
        } finally {
            // Always publish build info
            publishBuildInfo(buildName, buildNumber)
        }
    }
}

def setupBuildEnvironment(jfcmRepoDir) {
    dir(jfcmRepoDir) {
        // Environment-aware Go installation
        // Use the same isLocalTesting check as the main pipeline
        def jenkinsUrl = env.JENKINS_URL ?: env.BUILD_URL ?: ''
        def isLocal = params.LOCAL_TESTING == true ||
                      jenkinsUrl.contains('localhost') || 
                      jenkinsUrl.contains('127.0.0.1') ||
                      jenkinsUrl.contains('host.docker.internal') ||
                      env.NODE_NAME == 'master' ||
                      env.NODE_NAME == 'built-in'
        
        if (isLocal) {
            // Local environment - install Go 1.23 in user space (from working Jenkinsfile.local)
            sh """
                echo "🔧 Setting up local build environment..."
                
                # Check current Go version
                echo "Current Go version: \$(go version)"
                
                # Install Go 1.23 in user space if needed (supports go.mod 1.24)
                if ! go version | grep -q "go1.23"; then
                    echo "📥 Installing Go 1.23 for go.mod 1.24 compatibility..."
                    
                    # Download and install Go 1.23 in user space
                    curl -L -o go1.23.tar.gz "https://go.dev/dl/go1.23.2.linux-amd64.tar.gz"
                    
                    # Install in user home directory
                    rm -rf ~/go-1.23
                    mkdir -p ~/go-1.23
                    tar -C ~/go-1.23 -xzf go1.23.tar.gz
                    rm go1.23.tar.gz
                    
                    # Update PATH for this session
                    export PATH="\$HOME/go-1.23/go/bin:\$PATH"
                    export GOROOT="\$HOME/go-1.23/go"
                    
                    echo "✅ Go 1.23 installed in user space"
                    echo "New Go version: \$(go version)"
                else
                    echo "✅ Go 1.23 already available"
                fi
            """
        } else {
            // Production environment - use system Go or install as needed
            sh """
                if ! command -v go >/dev/null 2>&1; then
                    echo "Installing Go for production..."
                    wget -q https://golang.org/dl/go1.23.2.linux-amd64.tar.gz
                    sudo tar -C /usr/local -xzf go1.23.2.linux-amd64.tar.gz
                    export PATH=\$PATH:/usr/local/go/bin
                fi
                go version
            """
        }
        
        // Verify build directory structure (identical for both environments)
        sh """
            mkdir -p build/{sign,apple_release/scripts,npm/v1,chocolatey/v1,deb_rpm/v1/build-scripts,docker,getcli,installcli,setupcli}
            mkdir -p dist/{binaries,packages,signed}
        """
        
        // Download dependencies (identical for both environments)
        sh "go mod download"
        sh "go mod verify"
    }
}

def buildJfvmBinaries(architectures, jfcmExecutableName, jfcmRepoDir, version) {
    def buildSteps = [:]
    
    architectures.each { architecture ->
        def goos = architecture.goos
        def goarch = architecture.goarch
        def pkg = architecture.pkg
        def fileExtension = architecture.fileExtension
        def fileName = "${jfcmExecutableName}${fileExtension}"
        
        buildSteps["${pkg}"] = {
            build(goos, goarch, pkg, fileName, jfcmRepoDir, version)
        }
    }
    
    // Build all architectures in parallel
    parallel buildSteps
}

def build(goos, goarch, pkg, fileName, jfcmRepoDir, version) {
    dir(jfcmRepoDir) {
        echo "Building ${pkg} (${goos}/${goarch})..."
        
        // Set build environment
        env.GOOS = goos
        env.GOARCH = goarch
        env.CGO_ENABLED = "0"
        
        // Build with version information
        def ldflags = "-w -extldflags \"-static\" -X main.Version=${version} -X main.BuildDate=\$(date -u '+%Y-%m-%d_%H:%M:%S') -X main.GitCommit=\$(git rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
        
        sh """
            echo "Building ${fileName} for ${goos}/${goarch}..."
            go build -o "dist/binaries/${pkg}/${fileName}" -ldflags '${ldflags}' main.go
            chmod +x "dist/binaries/${pkg}/${fileName}"
            
            # Verify the binary
            if [ "${goos}" = "linux" ] && [ "${goarch}" = "amd64" ]; then
                echo "Testing binary on current platform..."
                ./dist/binaries/${pkg}/${fileName} --version || echo "Binary test failed but continuing..."
            fi
        """
        
        // Clean up environment variables
        env.GOOS = ""
        env.GOARCH = ""
        env.CGO_ENABLED = ""
        
        echo "Successfully built ${pkg}/${fileName}"
    }
}

def signBinaries(architectures, jfcmExecutableName, jfcmRepoDir) {
    def signingSteps = [:]
    
    architectures.each { architecture ->
        def goos = architecture.goos
        def pkg = architecture.pkg
        def fileExtension = architecture.fileExtension
        def fileName = "${jfcmExecutableName}${fileExtension}"
        
        if (goos == 'windows') {
            signingSteps["sign-${pkg}"] = {
                signWindowsBinary(pkg, fileName, jfcmRepoDir)
            }
        } else if (goos == 'darwin') {
            signingSteps["sign-${pkg}"] = {
                signMacOSBinary(pkg, fileName, jfcmRepoDir)
            }
        }
    }
    
    if (signingSteps.size() > 0) {
        parallel signingSteps
    } else {
        echo "No binaries require signing"
    }
}

def signWindowsBinary(pkg, fileName, jfcmRepoDir) {
    dir("${jfcmRepoDir}/build/sign") {
        echo "Signing Windows binary: ${pkg}/${fileName}"
        
        // Move unsigned binary
        sh "cp ../../dist/binaries/${pkg}/${fileName} ${fileName}.unsigned"
        
        // Build signing container if it doesn't exist
        sh """
            if [ ! -f Dockerfile ]; then
                cat > Dockerfile << 'EOF'
FROM jfrog-docker/linuturk/mono-choco:latest

# Install signing tools
RUN apt-get update && apt-get install -y osslsigncode

# Copy signing script
COPY sign-windows.sh /usr/local/bin/sign-windows.sh
RUN chmod +x /usr/local/bin/sign-windows.sh

ENTRYPOINT ["/usr/local/bin/sign-windows.sh"]
EOF
            fi
        """
        
        // Create signing script if it doesn't exist
        sh """
            if [ ! -f sign-windows.sh ]; then
                cat > sign-windows.sh << 'EOF'
#!/bin/bash
set -e

INPUT_FILE=""
OUTPUT_FILE=""

while [[ \$# -gt 0 ]]; do
    case \$1 in
        -in)
            INPUT_FILE="\$2"
            shift 2
            ;;
        -out)
            OUTPUT_FILE="\$2"
            shift 2
            ;;
        *)
            echo "Unknown option: \$1"
            exit 1
            ;;
    esac
done

if [ -z "\$INPUT_FILE" ] || [ -z "\$OUTPUT_FILE" ]; then
    echo "Usage: \$0 -in <input_file> -out <output_file>"
    exit 1
fi

echo "Signing \$INPUT_FILE -> \$OUTPUT_FILE"

# For now, just copy the file (replace with actual signing)
# osslsigncode sign -certs "\$CERT_FILE" -key "\$KEY_FILE" -in "\$INPUT_FILE" -out "\$OUTPUT_FILE"
cp "\$INPUT_FILE" "\$OUTPUT_FILE"

echo "Signing completed"
EOF
                chmod +x sign-windows.sh
            fi
        """
        
        withCredentials([
            file(credentialsId: 'windows-signing-cert', variable: 'WINDOWS_CERT_FILE'),
            string(credentialsId: 'windows-signing-password', variable: 'WINDOWS_CERT_PASSWORD')
        ]) {
            sh """
                docker build -t jfcm-sign-tool .
                docker run -v \$(pwd):/workspace \
                    -e CERT_FILE=/workspace/cert.p12 \
                    -e CERT_PASSWORD=\${WINDOWS_CERT_PASSWORD} \
                    jfcm-sign-tool -in ${fileName}.unsigned -out ${fileName}
            """
        }
        
        // Move signed binary back
        sh "cp ${fileName} ../../dist/signed/${pkg}/"
        sh "mkdir -p ../../dist/signed/${pkg}"
        sh "cp ${fileName} ../../dist/signed/${pkg}/"
    }
}

def signMacOSBinary(pkg, fileName, jfcmRepoDir) {
    dir("${jfcmRepoDir}/build/apple_release/scripts") {
        echo "Signing macOS binary: ${pkg}/${fileName}"
        
        // Create signing script if it doesn't exist
        sh """
            if [ ! -f darwin-sign-and-notarize.sh ]; then
                cat > darwin-sign-and-notarize.sh << 'EOF'
#!/bin/bash
set -e

BINARY_PATH="\$1"
OUTPUT_PATH="\$2"

echo "Signing macOS binary: \$BINARY_PATH"

# For now, just copy the binary (replace with actual signing and notarization)
# codesign -s "\$APPLE_TEAM_ID" --timestamp --deep --options runtime --force "\$BINARY_PATH"
# xcrun notarytool submit "\$BINARY_PATH" --apple-id "\$APPLE_ACCOUNT_ID" --team-id "\$APPLE_TEAM_ID" --password "\$APPLE_APP_SPECIFIC_PASSWORD" --wait

cp "\$BINARY_PATH" "\$OUTPUT_PATH"

echo "Signing and notarization completed"
EOF
                chmod +x darwin-sign-and-notarize.sh
            fi
        """
        
        withCredentials([
            string(credentialsId: 'apple-team-id', variable: 'APPLE_TEAM_ID'),
            string(credentialsId: 'apple-account-id', variable: 'APPLE_ACCOUNT_ID'),
            string(credentialsId: 'apple-app-password', variable: 'APPLE_APP_SPECIFIC_PASSWORD')
        ]) {
            sh """
                mkdir -p ../../../dist/signed/${pkg}
                ./darwin-sign-and-notarize.sh "../../../dist/binaries/${pkg}/${fileName}" "../../../dist/signed/${pkg}/${fileName}"
            """
        }
    }
}

def createPackages(architectures, jfcmExecutableName, jfcmRepoDir, version, identifier) {
    def packageSteps = [:]
    
    // Create NPM package
    packageSteps['npm'] = {
        createNpmPackage(jfcmExecutableName, jfcmRepoDir, version, identifier)
    }
    
    // Create Chocolatey package
    packageSteps['chocolatey'] = {
        createChocolateyPackage(jfcmExecutableName, jfcmRepoDir, version, identifier)
    }
    
    // Create Debian packages
    architectures.findAll { it.goos == 'linux' && it.debianImage }.each { architecture ->
        packageSteps["deb-${architecture.pkg}"] = {
            createDebianPackage(architecture, jfcmExecutableName, jfcmRepoDir, version, identifier)
        }
    }
    
    // Create RPM packages
    architectures.findAll { it.goos == 'linux' && it.rpmImage }.each { architecture ->
        packageSteps["rpm-${architecture.pkg}"] = {
            createRpmPackage(architecture, jfcmExecutableName, jfcmRepoDir, version, identifier)
        }
    }
    
    // Create Docker images
    packageSteps['docker'] = {
        createDockerImages(jfcmExecutableName, jfcmRepoDir, version)
    }
    
    parallel packageSteps
}

def createNpmPackage(jfcmExecutableName, jfcmRepoDir, version, identifier) {
    dir("${jfcmRepoDir}/build/npm/${identifier}") {
        echo "Creating NPM package..."
        
        // Create package.json
        def cleanVersion = version.startsWith('v') ? version.substring(1) : version
        writeFile file: 'package.json', text: """
{
    "name": "@jfrog/jfcm",
    "version": "${cleanVersion}",
    "description": "JFrog CLI Version Manager - Manage multiple versions of JFrog CLI",
    "main": "init.js",
    "bin": {
        "jfcm": "./bin/jfcm"
    },
    "scripts": {
        "install": "node init.js"
    },
    "keywords": [
        "jfrog",
        "cli",
        "version-manager",
        "devops",
        "ci-cd",
        "artifactory"
    ],
    "author": "JFrog Ltd.",
    "license": "MIT",
    "repository": {
        "type": "git",
        "url": "https://github.com/jfrog/jfrog-cli-vm.git"
    },
    "engines": {
        "node": ">=14.0.0"
    },
    "preferGlobal": true,
    "os": ["darwin", "linux", "win32"],
    "cpu": ["x64", "arm64", "ia32"]
}
"""
        
        // Create init.js installer script
        writeFile file: 'init.js', text: '''
const {get} = require("https");
const {createWriteStream, chmodSync, existsSync, mkdirSync} = require("fs");
const {join} = require("path");
const {promisify} = require("util");
const readline = require("readline");

function getArchitecture() {
    const platform = process.platform;
    if (platform.startsWith("win")) {
        return "windows-amd64";
    }
    const arch = process.arch;
    if (platform.includes("darwin")) {
        return arch === "arm64" ? "mac-arm64" : "mac-amd64";
    }
    
    // Linux architectures
    switch (arch) {
        case "x64": return "linux-amd64";
        case "arm64": return "linux-arm64";
        case "arm": return "linux-arm";
        case "s390x": return "linux-s390x";
        case "ppc64": return "linux-ppc64";
        default: return "linux-386";
    }
}

function promptJfrogCliInstallation() {
    if (process.env.npm_config_install_with_jfrog_cli === 'true' || process.argv.includes('--install-with-jfrog-cli')) {
        return Promise.resolve(true);
    }
    
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
    
    console.log("");
    console.log("\\u001b[33m╔═══════════════════════════════════════════════════════════════════╗\\u001b[0m");
    console.log("\\u001b[33m║                    Optional Component: JFrog CLI                 ║\\u001b[0m");
    console.log("\\u001b[33m╚═══════════════════════════════════════════════════════════════════╝\\u001b[0m");
    console.log("");
    console.log("JFrog CLI provides comprehensive artifact management capabilities.");
    console.log("Installing it alongside JFVM enables full JFrog platform integration.");
    console.log("");
    console.log("📖 Learn more: https://docs.jfrog-applications.jfrog.io/jfrog-applications/jfrog-cli");
    console.log("");
    
    return new Promise((resolve) => {
        rl.question("Install JFrog CLI alongside JFVM? [y/N]: ", (answer) => {
            rl.close();
            resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
        });
    });
}

async function downloadFile(url, dest) {
    return new Promise((resolve, reject) => {
        const file = createWriteStream(dest);
        get(url, (response) => {
            if (response.statusCode !== 200) {
                reject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`));
                return;
            }
            response.pipe(file);
            file.on('finish', () => {
                file.close();
                resolve();
            });
            file.on('error', reject);
        }).on('error', reject);
    });
}

async function downloadJfvm() {
    const architecture = getArchitecture();
    const version = require("./package.json").version;
    const fileName = process.platform.startsWith("win") ? "jfcm.exe" : "jfcm";
    const url = `https://releases.jfrog.io/artifactory/jfcm/v1/${version}/jfcm-${architecture}/${fileName}`;
    
    console.log(`Downloading JFVM ${version} for ${architecture}...`);
    
    const binDir = join(__dirname, "bin");
    if (!existsSync(binDir)) {
        mkdirSync(binDir, { recursive: true });
    }
    
    const binPath = join(binDir, fileName);
    
    try {
        await downloadFile(url, binPath);
        if (!process.platform.startsWith("win")) {
            chmodSync(binPath, 0o755);
        }
        console.log(`\\u001b[32m✅ JFVM installed successfully to ${binPath}\\u001b[0m`);
    } catch (error) {
        console.error(`\\u001b[31m❌ Failed to download JFVM: ${error.message}\\u001b[0m`);
        process.exit(1);
    }
}

async function downloadJfrogCli() {
    const {execSync} = require("child_process");
    
    console.log("Installing JFrog CLI...");
    
    try {
        // Install JFrog CLI using npm
        execSync("npm install -g @jfrog/jfrog-cli-v2-jf", { stdio: "inherit" });
        console.log("\\u001b[32m✅ JFrog CLI installed successfully\\u001b[0m");
    } catch (error) {
        console.error(`\\u001b[31m❌ Failed to install JFrog CLI: ${error.message}\\u001b[0m`);
        console.log("You can install JFrog CLI manually later using: npm install -g @jfrog/jfrog-cli-v2-jf");
    }
}

async function main() {
    console.log("\\u001b[34m");
    console.log("╔═══════════════════════════════════════════════════════════════════╗");
    console.log("║                     JFVM Installation                            ║");
    console.log("║                                                                   ║");
    console.log("║  Installing JFrog CLI Version Manager on your system...         ║");
    console.log("╚═══════════════════════════════════════════════════════════════════╝");
    console.log("\\u001b[0m");
    
    try {
        await downloadJfvm();
        
        const installJfrogCli = await promptJfrogCliInstallation();
        if (installJfrogCli) {
            await downloadJfrogCli();
        }
        
        console.log("");
        console.log("\\u001b[32m╔═══════════════════════════════════════════════════════════════════╗\\u001b[0m");
        console.log("\\u001b[32m║                    Installation Complete!                        ║\\u001b[0m");
        console.log("\\u001b[32m╚═══════════════════════════════════════════════════════════════════╝\\u001b[0m");
        console.log("");
        console.log("\\u001b[34mNext steps:\\u001b[0m");
        console.log("  jfcm install latest    # Install latest JFrog CLI");
        console.log("  jfcm use latest        # Switch to latest version");
        console.log("  jfcm --help            # Show all commands");
        console.log("");
        
    } catch (error) {
        console.error(`\\u001b[31m❌ Installation failed: ${error.message}\\u001b[0m`);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}
'''
        
        sh """
            mkdir -p ../../../dist/packages/npm
            tar -czf "../../../dist/packages/npm/jfcm-${version}.tgz" .
        """
        
        echo "NPM package created successfully"
    }
}

def createChocolateyPackage(jfcmExecutableName, jfcmRepoDir, version, identifier) {
    dir("${jfcmRepoDir}/build/chocolatey/${identifier}") {
        echo "Creating Chocolatey package..."
        
        def cleanVersion = version.replaceFirst('^v', '')
        
        // Create nuspec file
        writeFile file: 'jfcm.nuspec', text: """
<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd">
  <metadata>
    <id>jfcm</id>
    <version>${cleanVersion}</version>
    <packageSourceUrl>https://github.com/jfrog/jfrog-cli-vm</packageSourceUrl>
    <owners>JFrog</owners>
    <title>JFVM (JFrog CLI Version Manager)</title>
    <authors>JFrog Ltd.</authors>
    <projectUrl>https://github.com/jfrog/jfrog-cli-vm</projectUrl>
    <iconUrl>https://raw.githubusercontent.com/jfrog/jfrog-cli-vm/main/docs/images/jfcm-icon.png</iconUrl>
    <copyright>2024 JFrog Ltd.</copyright>
    <licenseUrl>https://raw.githubusercontent.com/jfrog/jfrog-cli-vm/main/LICENSE</licenseUrl>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <projectSourceUrl>https://github.com/jfrog/jfrog-cli-vm</projectSourceUrl>
    <docsUrl>https://github.com/jfrog/jfrog-cli-vm/blob/main/README.md</docsUrl>
    <bugTrackerUrl>https://github.com/jfrog/jfrog-cli-vm/issues</bugTrackerUrl>
    <tags>jfrog cli version-manager devops ci-cd artifactory</tags>
    <summary>Manage multiple versions of JFrog CLI with ease</summary>
    <description>
JFVM (JFrog CLI Version Manager) is a powerful tool that helps you manage multiple versions of JFrog CLI on your system. 

Features:
* Install and manage multiple JFrog CLI versions
* Switch between versions easily
* Set project-specific JFrog CLI versions
* Compare performance between versions
* Track usage analytics
* Automatic version detection from .jfrog-version files

Use --params '/InstallJfrogCli' to also install JFrog CLI alongside JFVM.
    </description>
    <releaseNotes>https://github.com/jfrog/jfrog-cli-vm/releases/tag/${version}</releaseNotes>
  </metadata>
  <files>
    <file src="tools\\**" target="tools" />
  </files>
</package>
"""
        
        // Create tools directory and scripts
        sh "mkdir -p tools"
        
        writeFile file: 'tools/chocolateyinstall.ps1', text: '''
$ErrorActionPreference = 'Stop'

$packageName = 'jfcm'
$version = $env:ChocolateyPackageVersion
$packageParameters = Get-PackageParameters

Write-Host "Installing JFVM (JFrog CLI Version Manager)..." -ForegroundColor Green

$packageArgs = @{
    packageName   = $packageName
    fileType      = 'exe'
    url           = "https://releases.jfrog.io/artifactory/jfcm/v1/$version/jfcm-windows-amd64/jfcm.exe"
    checksum      = ''  # Will be populated during build
    checksumType  = 'sha256'
}

$toolsDir = "$(Split-Path -parent $MyInvocation.MyCommand.Definition)"
$jfcmPath = Join-Path $toolsDir "jfcm.exe"

Get-ChocolateyWebFile -PackageName $packageName -FileFullPath $jfcmPath -Url $packageArgs.url -Checksum $packageArgs.checksum -ChecksumType $packageArgs.checksumType

# Add to PATH
Install-ChocolateyPath $toolsDir

# Check if user wants to install JFrog CLI
$installJfrogCli = $packageParameters['InstallJfrogCli']
if ($installJfrogCli) {
    Write-Host ""
    Write-Host "Installing JFrog CLI alongside JFVM..." -ForegroundColor Cyan
    try {
        choco install jfrog-cli-v2-jf -y
        Write-Host "✅ JFrog CLI installed successfully" -ForegroundColor Green
    } catch {
        Write-Warning "Failed to install JFrog CLI: $_"
        Write-Host "You can install JFrog CLI manually later using: choco install jfrog-cli-v2-jf"
    }
} else {
    Write-Host ""
    Write-Host "💡 Tip: You can install JFrog CLI later using:" -ForegroundColor Blue
    Write-Host "   choco install jfrog-cli-v2-jf"
    Write-Host "   Or reinstall JFVM with: choco install jfcm --params '/InstallJfrogCli'"
}

Write-Host ""
Write-Host "✅ JFVM installation completed!" -ForegroundColor Green
Write-Host ""
Write-Host "Next steps:" -ForegroundColor Blue
Write-Host "  jfcm install latest    # Install latest JFrog CLI"
Write-Host "  jfcm use latest        # Switch to latest version"
Write-Host "  jfcm --help            # Show all commands"
'''

        writeFile file: 'tools/chocolateyuninstall.ps1', text: '''
$ErrorActionPreference = 'Stop'

$packageName = 'jfcm'
$toolsDir = "$(Split-Path -parent $MyInvocation.MyCommand.Definition)"
$jfcmPath = Join-Path $toolsDir "jfcm.exe"

Write-Host "Uninstalling JFVM..." -ForegroundColor Yellow

# Remove binary
if (Test-Path $jfcmPath) {
    Remove-Item $jfcmPath -Force
    Write-Host "Removed JFVM binary" -ForegroundColor Green
}

# Remove from PATH (Chocolatey handles this automatically)

Write-Host "✅ JFVM uninstalled successfully" -ForegroundColor Green
'''

        writeFile file: 'tools/VERIFICATION.txt', text: """
VERIFICATION
Verification is intended to assist the Chocolatey moderators and community
in verifying that this package's contents are trustworthy.

Package can be verified like this:

1. Download JFVM from the official JFrog releases:
   https://releases.jfrog.io/artifactory/jfcm/v1/${cleanVersion}/jfcm-windows-amd64/jfcm.exe

2. You can use one of the following methods to obtain the SHA256 checksum:
   - Use powershell function 'Get-FileHash'
   - Use Chocolatey utility 'checksum.exe'

   checksum type: sha256
   checksum: [Will be updated during build]

File 'LICENSE.txt' is obtained from:
   https://raw.githubusercontent.com/jfrog/jfrog-cli-vm/main/LICENSE
"""
        
        sh """
            mkdir -p ../../../dist/packages/chocolatey
            # Package will be created during the signing phase
            echo "Chocolatey package prepared"
        """
    }
}

def createDebianPackage(architecture, jfcmExecutableName, jfcmRepoDir, version, identifier) {
    def pkg = architecture.pkg
    def goarch = architecture.goarch
    def debianImage = architecture.debianImage
    def debianArch = architecture.debianArch
    
    echo "Creating Debian package for ${pkg}..."
    
    dir("${jfcmRepoDir}/build/deb_rpm/${identifier}/build-scripts") {
        // Use the signed binary if available, otherwise use the unsigned one
        def binaryPath = fileExists("../../../../dist/signed/${pkg}/${jfcmExecutableName}") ? 
            "../../../../dist/signed/${pkg}/${jfcmExecutableName}" : 
            "../../../../dist/binaries/${pkg}/${jfcmExecutableName}"
            
        sh """
            docker run --rm -v \$(pwd)/../../../../:/workspace ${debianImage} bash -c "
                cd /workspace
                
                # Install build dependencies
                apt-get update
                apt-get install -y build-essential debhelper devscripts
                
                # Create package structure
                mkdir -p build/deb/${pkg}/DEBIAN
                mkdir -p build/deb/${pkg}/usr/bin
                mkdir -p build/deb/${pkg}/usr/share/doc/jfcm
                
                # Copy binary
                cp ${binaryPath} build/deb/${pkg}/usr/bin/jfcm
                chmod 755 build/deb/${pkg}/usr/bin/jfcm
                
                # Create control file
                cat > build/deb/${pkg}/DEBIAN/control << EOF
Package: jfcm
Version: \$(echo "${version}" | sed 's/^v//')
Section: utils
Priority: optional
Architecture: ${debianArch}
Depends: libc6
Maintainer: JFrog Ltd. <support@jfrog.com>
Description: JFrog CLI Version Manager
 JFVM (JFrog CLI Version Manager) is a powerful tool that helps you manage
 multiple versions of JFrog CLI on your system. Features include:
 .
 * Install and manage multiple JFrog CLI versions
 * Switch between versions easily
 * Set project-specific JFrog CLI versions
 * Compare performance between versions
 * Track usage analytics
Homepage: https://github.com/jfrog/jfrog-cli-vm
EOF

                # Create postinst script
                cat > build/deb/${pkg}/DEBIAN/postinst << 'EOF'
#!/bin/bash
set -e

echo \"\"
echo \"✅ JFVM installed successfully!\"
echo \"\"
echo \"💡 Optional: Install JFrog CLI for full JFrog platform integration:\"
echo \"   curl -fL https://install-cli.jfrog.io | sh\"
echo \"\"
echo \"Next steps:\"
echo \"  jfcm install latest    # Install latest JFrog CLI\"
echo \"  jfcm use latest        # Switch to latest version\"
echo \"  jfcm --help            # Show all commands\"
echo \"\"
EOF
                chmod 755 build/deb/${pkg}/DEBIAN/postinst
                
                # Create copyright file
                cat > build/deb/${pkg}/usr/share/doc/jfcm/copyright << EOF
Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
Upstream-Name: jfcm
Source: https://github.com/jfrog/jfrog-cli-vm

Files: *
Copyright: 2024 JFrog Ltd.
License: MIT
EOF

                # Build package
                dpkg-deb --build build/deb/${pkg}
                CLEAN_VERSION=\$(echo "${version}" | sed 's/^v//')
                mv build/deb/${pkg}.deb dist/packages/jfcm_\${CLEAN_VERSION}_${debianArch}.deb
            "
        """
    }
}

def createRpmPackage(architecture, jfcmExecutableName, jfcmRepoDir, version, identifier) {
    def pkg = architecture.pkg
    def rpmImage = architecture.rpmImage
    
    echo "Creating RPM package for ${pkg}..."
    
    dir("${jfcmRepoDir}/build/deb_rpm/${identifier}/build-scripts") {
        def binaryPath = fileExists("../../../../dist/signed/${pkg}/${jfcmExecutableName}") ? 
            "../../../../dist/signed/${pkg}/${jfcmExecutableName}" : 
            "../../../../dist/binaries/${pkg}/${jfcmExecutableName}"
            
        sh """
            docker run --rm -v \$(pwd)/../../../../:/workspace ${rpmImage} bash -c "
                cd /workspace
                
                # Install build dependencies
                dnf install -y rpm-build rpmdevtools
                
                # Setup RPM build environment
                rpmdev-setuptree
                
                # Create spec file
                CLEAN_VERSION=\$(echo "${version}" | sed 's/^v//')
                cat > ~/rpmbuild/SPECS/jfcm.spec << EOF
Name:           jfcm
Version:        \${CLEAN_VERSION}
Release:        1%{?dist}
Summary:        JFrog CLI Version Manager
License:        MIT
URL:            https://github.com/jfrog/jfrog-cli-vm
Source0:        jfcm
BuildArch:      x86_64

%description
JFVM (JFrog CLI Version Manager) is a powerful tool that helps you manage
multiple versions of JFrog CLI on your system. Features include:

* Install and manage multiple JFrog CLI versions
* Switch between versions easily  
* Set project-specific JFrog CLI versions
* Compare performance between versions
* Track usage analytics

%install
mkdir -p %{buildroot}%{_bindir}
cp %{SOURCE0} %{buildroot}%{_bindir}/jfcm
chmod 755 %{buildroot}%{_bindir}/jfcm

%files
%{_bindir}/jfcm

%post
echo \"\"
echo \"✅ JFVM installed successfully!\"
echo \"\"
echo \"💡 Optional: Install JFrog CLI for full JFrog platform integration:\"
echo \"   curl -fL https://install-cli.jfrog.io | sh\"
echo \"\"
echo \"Next steps:\"
echo \"  jfcm install latest    # Install latest JFrog CLI\"
echo \"  jfcm use latest        # Switch to latest version\"
echo \"  jfcm --help            # Show all commands\"
echo \"\"

%changelog
* \$(date +'%a %b %d %Y') JFrog Release Team <support@jfrog.com> - \$(echo "${version}" | sed 's/^v//')-1
- Release ${version}
EOF

                # Copy source
                cp ${binaryPath} ~/rpmbuild/SOURCES/jfcm
                
                # Build RPM
                rpmbuild -ba ~/rpmbuild/SPECS/jfcm.spec
                
                # Copy result
                mkdir -p dist/packages
                cp ~/rpmbuild/RPMS/x86_64/jfcm-*.rpm dist/packages/
            "
        """
    }
}

def createDockerImages(jfcmExecutableName, jfcmRepoDir, version) {
    dir("${jfcmRepoDir}/build/docker") {
        echo "Creating Docker images..."
        
        // Create slim Docker image
        dir("slim") {
            writeFile file: 'Dockerfile', text: """
FROM alpine:latest

# Install dependencies
RUN apk add --no-cache ca-certificates git curl

# Create jfcm user
RUN addgroup -g 1000 jfcm && \\
    adduser -D -s /bin/sh -u 1000 -G jfcm jfcm

# Copy JFVM binary
COPY jfcm /usr/local/bin/jfcm
RUN chmod +x /usr/local/bin/jfcm

# Switch to jfcm user
USER jfcm
WORKDIR /home/jfcm

# Initialize JFVM
RUN jfcm --version

ENTRYPOINT ["jfcm"]
CMD ["--help"]
"""
            
            sh """
                cp ../../../dist/binaries/jfcm-linux-amd64/jfcm .
                docker build -t jfrog/jfcm:${version} .
                docker tag jfrog/jfcm:${version} jfrog/jfcm:latest
                
                # Save image
                mkdir -p ../../../dist/packages/docker
                docker save jfrog/jfcm:${version} | gzip > ../../../dist/packages/docker/jfcm-${version}.tar.gz
            """
        }
        
        // Create full Docker image with JFrog CLI
        dir("full") {
            writeFile file: 'Dockerfile', text: """
FROM alpine:latest

# Install dependencies
RUN apk add --no-cache ca-certificates git curl bash

# Create jfcm user
RUN addgroup -g 1000 jfcm && \\
    adduser -D -s /bin/bash -u 1000 -G jfcm jfcm

# Install JFrog CLI
RUN curl -fL https://install-cli.jfrog.io | sh && \\
    mv jf /usr/local/bin/jf && \\
    chmod +x /usr/local/bin/jf

# Copy JFVM binary
COPY jfcm /usr/local/bin/jfcm
RUN chmod +x /usr/local/bin/jfcm

# Switch to jfcm user
USER jfcm
WORKDIR /home/jfcm

# Initialize JFVM and install latest JF CLI
RUN jfcm --version && \\
    jfcm install latest && \\
    jfcm use latest

ENTRYPOINT ["jfcm"]
CMD ["--help"]
"""
            
            sh """
                cp ../../../dist/binaries/jfcm-linux-amd64/jfcm .
                docker build -t jfrog/jfcm:${version}-full .
                docker tag jfrog/jfcm:${version}-full jfrog/jfcm:latest-full
                
                # Save image
                docker save jfrog/jfcm:${version}-full | gzip > ../../../dist/packages/docker/jfcm-${version}-full.tar.gz
            """
        }
    }
}

def testPackages(architectures, jfcmExecutableName, jfcmRepoDir) {
    echo "Testing packages..."
    
    dir(jfcmRepoDir) {
        // Test NPM package
        sh """
            if [ -f dist/packages/npm/jfcm-*.tgz ]; then
                echo "Testing NPM package..."
                cd /tmp
                npm pack ../dist/packages/npm/jfcm-*.tgz
                echo "NPM package test passed"
            fi
        """
        
        // Test Docker images
        sh """
            if docker images | grep -q jfrog/jfcm; then
                echo "Testing Docker image..."
                docker run --rm jfrog/jfcm:latest --version
                echo "Docker image test passed"
            fi
        """
        
        // Test Linux binaries on current platform
        architectures.findAll { it.goos == 'linux' && it.goarch == 'amd64' }.each { architecture ->
            def pkg = architecture.pkg
            def fileName = jfcmExecutableName
            
            def binaryPath = fileExists("dist/signed/${pkg}/${fileName}") ? 
                "dist/signed/${pkg}/${fileName}" : 
                "dist/binaries/${pkg}/${fileName}"
                
            if (fileExists(binaryPath)) {
                sh """
                    echo "Testing ${pkg} binary..."
                    ${binaryPath} --version
                    echo "${pkg} binary test passed"
                """
            }
        }
    }
}

def uploadToArtifactory(architectures, jfcmExecutableName, jfcmRepoDir, version, identifier, buildName, buildNumber) {
    dir(jfcmRepoDir) {
        // Environment detection
        def isLocal = env.JENKINS_URL?.contains('localhost')
        
        // Use configurable credentials and URLs
        def credentialsId = isLocal ? 'local-artifactory-creds' : 'repo21'
        def artifactoryUrl = isLocal ? 
            "http://host.docker.internal:8082/artifactory" : 
            "https://releases.jfrog.io/artifactory"
        def binariesRepo = "jfcm"
        
        echo "📤 Uploading to: ${artifactoryUrl}"
        echo "Binaries repository: ${binariesRepo}"
        
        // For local testing, use direct credentials since credential store may not work
        if (isLocal) {
            sh """
                echo "📤 Uploading binaries to local Artifactory..."
                
                # Test connectivity first
                curl -f -s -u admin:password "${artifactoryUrl}/api/system/ping"
                echo "✅ Artifactory connectivity verified"
                
                # Upload binaries following JFrog CLI structure: jfcm/v2/{version}/jfcm-{platform}/jfcm
                find dist/binaries -type f -name "jfcm*" ! -name "*.sha256" | while read binary; do
                    PKG=\$(echo \$binary | cut -d'/' -f3)
                    FILENAME=\$(basename \$binary)
                    
                    # JFrog CLI structure: jfcm/v2/{version}/jfcm-{platform}/jfcm
                    UPLOAD_PATH="jfcm/v2/${version}/\${PKG}/\${FILENAME}"
                    UPLOAD_URL="${artifactoryUrl}/${binariesRepo}/\${UPLOAD_PATH}"
                    
                    echo "📤 Uploading \${PKG}/\${FILENAME} to \${UPLOAD_PATH}"
                    
                    curl -u admin:password \\
                        -X PUT \\
                        "\${UPLOAD_URL}" \\
                        -T "\$binary" || echo "Upload failed for \$binary"
                        
                    # Upload checksum if exists
                    if [ -f "\${binary}.sha256" ]; then
                        curl -u admin:password \\
                            -X PUT \\
                            "\${UPLOAD_URL}.sha256" \\
                            -T "\${binary}.sha256" || echo "Checksum upload failed"
                    fi
                done
                
                echo "📤 Uploading packages to local Artifactory..."
                
                # Upload NPM package
                if [ -f dist/packages/npm/jfcm-*.tgz ]; then
                    NPM_FILE=\$(ls dist/packages/npm/jfcm-*.tgz)
                    curl -u admin:password \\
                        -X PUT \\
                        "${artifactoryUrl}/jfcm-npm/${identifier}/\$(basename \$NPM_FILE)" \\
                        -T "\$NPM_FILE"
                fi
                
                # Upload Debian packages
                find dist/packages -name "*.deb" | while read DEB_FILE; do
                    curl -u admin:password \\
                        -X PUT \\
                        "${artifactoryUrl}/jfcm-debs/\$(basename \$DEB_FILE)" \\
                        -T "\$DEB_FILE"
                done
                
                # Upload RPM packages  
                find dist/packages -name "*.rpm" | while read RPM_FILE; do
                    curl -u admin:password \\
                        -X PUT \\
                        "${artifactoryUrl}/jfcm-rpms/\$(basename \$RPM_FILE)" \\
                        -T "\$RPM_FILE"
                done
                
                # Upload Docker images
                find dist/packages/docker -name "*.tar.gz" | while read DOCKER_FILE; do
                    curl -u admin:password \\
                        -X PUT \\
                        "${artifactoryUrl}/jfcm-docker/${version}/\$(basename \$DOCKER_FILE)" \\
                        -T "\$DOCKER_FILE"
                done
            """
        } else {
            // Production upload with credential store
            withCredentials([usernamePassword(credentialsId: credentialsId, usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_PASSWORD')]) {
                
                // Upload binaries
                architectures.each { architecture ->
                    def pkg = architecture.pkg
                    def fileExtension = architecture.fileExtension
                    def fileName = "${jfcmExecutableName}${fileExtension}"
                    
                    // Upload signed binary if available, otherwise unsigned
                    def binaryPath = fileExists("dist/signed/${pkg}/${fileName}") ? 
                        "dist/signed/${pkg}/${fileName}" : 
                        "dist/binaries/${pkg}/${fileName}"
                    
                    if (fileExists(binaryPath)) {
                        sh """
                            curl -u \${ARTIFACTORY_USER}:\${ARTIFACTORY_PASSWORD} \\
                                -X PUT \\
                                "${artifactoryUrl}/${binariesRepo}/${identifier}/${version}/${pkg}/${fileName}" \\
                                -T "${binaryPath}"
                        """
                    }
                }
                
                // Upload packages
                sh """
                    # Upload NPM package
                    if [ -f dist/packages/npm/jfcm-*.tgz ]; then
                        curl -u \${ARTIFACTORY_USER}:\${ARTIFACTORY_PASSWORD} \\
                            -X PUT \\
                            "${artifactoryUrl}/jfcm-npm/${identifier}/" \\
                            -T dist/packages/npm/jfcm-*.tgz
                    fi
                    
                    # Upload Debian packages
                    find dist/packages -name "*.deb" -exec curl -u \${ARTIFACTORY_USER}:\${ARTIFACTORY_PASSWORD} \\
                        -X PUT \\
                        "${artifactoryUrl}/jfcm-debs/" \\
                        -T {} \\;
                    
                    # Upload RPM packages  
                    find dist/packages -name "*.rpm" -exec curl -u \${ARTIFACTORY_USER}:\${ARTIFACTORY_PASSWORD} \\
                        -X PUT \\
                        "${artifactoryUrl}/jfcm-rpms/" \\
                        -T {} \\;
                    
                    # Upload Docker images
                    find dist/packages/docker -name "*.tar.gz" -exec curl -u \${ARTIFACTORY_USER}:\${ARTIFACTORY_PASSWORD} \\
                        -X PUT \\
                        "${artifactoryUrl}/jfcm-docker/${version}/" \\
                        -T {} \\;
                """
            }
        }
    }
}

def publishPackages(architectures, jfcmExecutableName, jfcmRepoDir, version, identifier) {
    dir(jfcmRepoDir) {
        parallel([
            'npm': {
                publishNpmPackage(version, identifier)
            },
            'chocolatey': {
                publishChocolateyPackage(version, identifier)
            },
            'docker': {
                publishDockerImages(version)
            }
        ])
    }
}

def publishNpmPackage(version, identifier) {
    withCredentials([string(credentialsId: 'npm-token', variable: 'NPM_TOKEN')]) {
        dir("build/npm/${identifier}") {
            sh """
                echo "//registry.npmjs.org/:_authToken=\${NPM_TOKEN}" > ~/.npmrc
                npm publish --access public
            """
        }
    }
}

def publishChocolateyPackage(version, identifier) {
    withCredentials([string(credentialsId: 'choco-api-key', variable: 'CHOCO_API_KEY')]) {
        dir("build/chocolatey/${identifier}") {
            // Get the Windows binary checksum
            def checksum = sh(
                script: "sha256sum ../../../dist/signed/jfcm-windows-amd64/jfcm.exe | cut -d' ' -f1 || sha256sum ../../../dist/binaries/jfcm-windows-amd64/jfcm.exe | cut -d' ' -f1",
                returnStdout: true
            ).trim()
            
            // Update checksum in install script
            sh """
                sed -i "s/checksum      = ''/checksum      = '${checksum}'/g" tools/chocolateyinstall.ps1
                
                # Create package
                choco pack
                
                # Push to Chocolatey
                CLEAN_VERSION=\$(echo "${version}" | sed 's/^v//')
                choco push jfcm.\${CLEAN_VERSION}.nupkg --api-key \${CHOCO_API_KEY}
            """
        }
    }
}

def publishDockerImages(version) {
    withCredentials([usernamePassword(credentialsId: 'docker-hub', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASSWORD')]) {
        sh """
            echo \${DOCKER_PASSWORD} | docker login -u \${DOCKER_USER} --password-stdin
            
            # Push images
            docker push jfrog/jfcm:${version}
            docker push jfrog/jfcm:latest
            docker push jfrog/jfcm:${version}-full
            docker push jfrog/jfcm:latest-full
        """
    }
}

def updateInstallationDocs(version) {
    echo "Updating installation documentation for version ${version}..."
    
    // Create installation scripts
    dir("build/installcli") {
        writeFile file: 'jfcm.sh', text: """#!/bin/bash
# JFVM Installation Script
# This script installs JFVM and optionally JFrog CLI

set -e

# Configuration
JFVM_VERSION="${version}"
INSTALL_DIR="/usr/local/bin"
JFVM_DIR="\$HOME/.jfcm"

# Colors
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
BLUE='\\033[0;34m'
NC='\\033[0m'

print_banner() {
    echo -e "\${BLUE}"
    echo "╔═══════════════════════════════════════════════════════════════════╗"
    echo "║                     JFVM Installation Script                     ║"
    echo "║                                                                   ║"
    echo "║  This script will install JFVM (JFrog CLI Version Manager)       ║"
    echo "║  You can optionally install JFrog CLI alongside JFVM.            ║"
    echo "╚═══════════════════════════════════════════════════════════════════╝"
    echo -e "\${NC}\\n"
}

detect_platform() {
    local os=\$(uname -s | tr '[:upper:]' '[:lower:]')
    local arch=\$(uname -m)
    
    case "\$os" in
        linux*)
            case "\$arch" in
                x86_64) echo "linux-amd64" ;;
                aarch64|arm64) echo "linux-arm64" ;;
                armv7l) echo "linux-arm" ;;
                i*86) echo "linux-386" ;;
                s390x) echo "linux-s390x" ;;
                ppc64le) echo "linux-ppc64le" ;;
                ppc64) echo "linux-ppc64" ;;
                *) echo "unsupported" ;;
            esac
            ;;
        darwin*)
            case "\$arch" in
                x86_64) echo "mac-amd64" ;;
                arm64) echo "mac-arm64" ;;
                *) echo "unsupported" ;;
            esac
            ;;
        *)
            echo "unsupported"
            ;;
    esac
}

prompt_jfrog_cli_installation() {
    if [ "\${JFVM_INSTALL_JFROG_CLI}" = "true" ]; then
        return 0
    fi
    
    if [ "\${JFVM_SILENT_INSTALL}" = "true" ]; then
        return 1
    fi
    
    echo ""
    echo -e "\${YELLOW}╔═══════════════════════════════════════════════════════════════════╗\${NC}"
    echo -e "\${YELLOW}║                    Optional Component: JFrog CLI                 ║\${NC}"
    echo -e "\${YELLOW}╚═══════════════════════════════════════════════════════════════════╝\${NC}"
    echo ""
    echo "JFrog CLI provides comprehensive artifact management capabilities."
    echo "Installing it alongside JFVM enables full JFrog platform integration."
    echo ""
    echo -e "📖 Learn more: \${BLUE}https://docs.jfrog-applications.jfrog.io/jfrog-applications/jfrog-cli\${NC}"
    echo ""
    printf "Install JFrog CLI alongside JFVM? [y/N]: "
    read -r response
    case "\$response" in
        [yY][eE][sS]|[yY])
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

install_jfcm() {
    local platform=\$(detect_platform)
    if [ "\$platform" = "unsupported" ]; then
        echo -e "\${RED}Error: Unsupported platform: \$(uname -s)-\$(uname -m)\${NC}"
        exit 1
    fi
    
    echo -e "\${BLUE}Installing JFVM \${JFVM_VERSION} for \${platform}...\${NC}"
    
    local download_url="https://releases.jfrog.io/artifactory/jfcm/v1/\${JFVM_VERSION}/jfcm-\${platform}/jfcm"
    local temp_file="/tmp/jfcm-\${JFVM_VERSION}"
    
    # Download JFVM
    if command -v curl >/dev/null 2>&1; then
        curl -L -f -o "\$temp_file" "\$download_url"
    elif command -v wget >/dev/null 2>&1; then
        wget -O "\$temp_file" "\$download_url"
    else
        echo -e "\${RED}Error: Neither curl nor wget is available\${NC}"
        exit 1
    fi
    
    # Install JFVM
    chmod +x "\$temp_file"
    
    if [ -w "\$INSTALL_DIR" ] || sudo cp "\$temp_file" "\$INSTALL_DIR/jfcm" 2>/dev/null; then
        echo -e "\${GREEN}JFVM installed to \$INSTALL_DIR/jfcm\${NC}"
    else
        local user_bin="\$HOME/.local/bin"
        mkdir -p "\$user_bin"
        cp "\$temp_file" "\$user_bin/jfcm"
        echo -e "\${GREEN}JFVM installed to \$user_bin/jfcm\${NC}"
        
        # Add to PATH
        if [[ ":\$PATH:" != *":\$user_bin:"* ]]; then
            echo "export PATH=\\"\\\$HOME/.local/bin:\\\$PATH\\"" >> "\$HOME/.bashrc"
            echo "export PATH=\\"\\\$HOME/.local/bin:\\\$PATH\\"" >> "\$HOME/.zshrc" 2>/dev/null || true
            echo -e "\${YELLOW}Added \$user_bin to PATH in shell configuration files\${NC}"
        fi
    fi
    
    rm -f "\$temp_file"
}

install_jfrog_cli() {
    echo -e "\${BLUE}Installing JFrog CLI...\${NC}"
    
    if curl -fL https://install-cli.jfrog.io | sh; then
        echo -e "\${GREEN}JFrog CLI installed successfully\${NC}"
    else
        echo -e "\${YELLOW}Failed to install JFrog CLI automatically\${NC}"
        echo "You can install it manually later using:"
        echo "  curl -fL https://install-cli.jfrog.io | sh"
    fi
}

main() {
    print_banner
    
    install_jfcm
    
    if prompt_jfrog_cli_installation; then
        install_jfrog_cli
    fi
    
    echo ""
    echo -e "\${GREEN}╔═══════════════════════════════════════════════════════════════════╗\${NC}"
    echo -e "\${GREEN}║                    Installation Complete!                        ║\${NC}"
    echo -e "\${GREEN}╚═══════════════════════════════════════════════════════════════════╝\${NC}"
    echo ""
    echo -e "\${GREEN}✅ JFVM installed successfully\${NC}"
    echo ""
    echo -e "\${BLUE}Next steps:\${NC}"
    echo "  jfcm install latest    # Install latest JFrog CLI"
    echo "  jfcm use latest        # Switch to latest version"
    echo "  jfcm --help            # Show all commands"
    echo ""
    echo -e "\${BLUE}Environment variables:\${NC}"
    echo "  JFVM_INSTALL_JFROG_CLI=true    # Auto-install JFrog CLI"
    echo "  JFVM_SILENT_INSTALL=true       # Skip prompts"
    echo ""
}

main "\$@"
"""
        
        sh """
            curl -u \${ARTIFACTORY_USER}:\${ARTIFACTORY_PASSWORD} \\
                -X PUT \\
                "https://releases.jfrog.io/artifactory/jfcm-installers/jfcm.sh" \\
                -T jfcm.sh
        """
    }
}

def cleanupBuildArtifacts(jfcmRepoDir) {
    dir(jfcmRepoDir) {
        sh """
            # Clean up temporary build artifacts but keep packages
            rm -rf build/sign/*.unsigned
            docker system prune -f || true
            
            echo "Build artifacts cleaned up"
        """
    }
}

def publishBuildInfo(buildName, buildNumber) {
    // Placeholder for build info publishing
    echo "Publishing build info for ${buildName} #${buildNumber}"
}


